/* This file is part of Into.
 * Copyright (C) 2003-2011 Intopii.
 * All rights reserved.
 *
 * IMPORTANT LICENSING INFORMATION
 *
 * Into is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License version 3
 * as published by the Free Software Foundation.
 *
 * Into is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with this program. If not, see
 * <http://www.gnu.org/licenses/>.
 */

#ifndef _PIITRACKEDPOINTERHOLDER_H
#define _PIITRACKEDPOINTERHOLDER_H

#include "PiiSerializationGlobal.h"

/**
 * A class that is used by PiiOutputArchive to store tracked
 * pointers while serializing them. When a tracked pointer of type @p
 * T is saved first time, PiiOutputArchive calls
 * PiiSerialization::createTrackedPointerHolder(T*) and inserts the
 * returned object to the list of tracked pointers. The list
 * is consulted whenever a tracked pointer is being saved. If its
 * address already exists, it won't be saved again. The stored
 * PiiTrackedPointerHolder instances will be deleted when the archive
 * is destroyed.
 *
 * If a pointer type requires special actions when saved, one can
 * create a specialization of
 * PiiSerialization::createTrackedPointerHolder(). The following
 * example shows how to ensure a refcounted object won't be deleted
 * during serialization.
 *
 *
 * @code
 * class MyRefCountedObjHolder : public PiiTrackedPointerHolder
 * {
 *   public:
 *     MyRefCountedObjHolder(const MyRefCountedObj* pointer) :
 *       PiiTrackedPointerHolder(pointer)
 *     {
 *       pointer->increaseRefCount();
 *     }
 *
 *     ~MyRefCountedObjHolder()
 *     {
 *       reinterpret_cast<const MyRefCountedObj*>(_pointer)->decreaseRefCount();
 *     }
 * };
 *
 * namespace PiiSerialization
 * {
 *   inline PiiTrackedPointerHolder* createTrackedPointerHolder(const MyRefCountedObj* ptr)
 *   {
 *     return new MyRefCountedObjHolder(ptr);
 *   }
 * }
 * @endcode
 *
 * @ingroup Serialization
 */
class PII_SERIALIZATION_EXPORT PiiTrackedPointerHolder
{
public:
  /**
   * Create a new pointer holder.
   *
   * @param pointer the memory address of a tracked object
   *
   * @param pointerIndex a serial number generated by
   * PiiOutputArchive.
   *
   * @param reference a flag that indicates whether the object was
   * saved through a reference.
   */
  PiiTrackedPointerHolder(const void* pointer = 0,
                          int pointerIndex = 0,
                          bool reference = false);
  
  virtual ~PiiTrackedPointerHolder();

  /**
   * Get the held pointer.
   */
  const void* pointer() const { return _pointer; }
  /**
   * Set the held pointer.
   */
  void setPointer(const void* pointer) { _pointer = pointer; }

  /**
   * Set the pointer index.
   */
  void setPointerIndex(int pointerIndex) { _iPointerIndex = pointerIndex; }
  /**
   * Get the pointer index.
   */
  int pointerIndex() const { return _iPointerIndex; }

  /**
   * See if the object pointed to by the held pointer was saved by a
   * reference.
   */
  bool isSavedByReference() const { return _bSavedByReference; }
  /**
   * Set the "saved by reference" flag.
   */
  void setSavedByReference(bool saved) { _bSavedByReference = saved; }
  
protected:
  /// The address of the tracked object.
  const void* _pointer;

private:
  int _iPointerIndex;
  bool _bSavedByReference;
};

namespace PiiSerialization
{
  /**
   * Create an instance of PiiTrackedPointerHolder. Override this
   * function if you want to provide a custom holder for your type.
   *
   * @relates PiiTrackedPointerHolder
   */
  inline PiiTrackedPointerHolder* createTrackedPointerHolder(const void* ptr)
  {
    return new PiiTrackedPointerHolder(ptr);
  }
}

#endif //_PIITRACKEDPOINTERHOLDER_H
